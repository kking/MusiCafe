package kking.musicafe;

import android.content.Context;
import android.media.AudioManager;
import android.media.SoundPool;
import android.os.Build;
import android.util.Log;
import android.view.View;

import java.util.HashMap;

import kking.musicafe.fragment.PianoFragment;

/**
 * MCSoundPool :
 * https://developer.android.com/reference/android/media/SoundPool
 *
 * @author kking
 */
public class MCSoundPool {
    private static final String TAG = "MCSoundPool";
    /** Constant length of note audio files. */
    private static final int NOTE_LENGTH = 10;
    /** Audio IDs; wav files for each note within one octave (C4-C5). */
    protected static final int[] NOTES_IDS = { R.raw.c4, R.raw.c_sharp_d_flat, R.raw.d, R.raw.d_sharp_e_flat,
            R.raw.e, R.raw.f, R.raw.f_sharp_g_flat, R.raw.g, R.raw.g_sharp_a_flat, R.raw.a, R.raw.a_sharp_b_flat,
            R.raw.b, R.raw.c5 };
    
    private SoundPool mSoundPool;
    /** The current stream ID. */
    private Integer mStreamId;
    /** Stream IDs generated by the SoundPool. */
    private int[] mSoundIds;
    /** A mapping from given Button IDs to the stream IDs generated by the SoundPool. */
    private HashMap<Integer, Integer> mSoundMap;

    /**Default constructor. */
    public MCSoundPool(Context context, int maxStreams) {
        // create SoundPool
        // old constructor is deprecated from API 21 (Lollipop)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            Log.i(TAG, "API > 21");
            // create a SoundPool with the given number of max streams
            mSoundPool = new SoundPool.Builder().setMaxStreams(maxStreams).build();
        }
        else {
            Log.i(TAG, "API < 21");
            // create a SoundPool using the connected device (headphones/speakers) for output
            mSoundPool = new SoundPool(maxStreams, AudioManager.STREAM_MUSIC, 0);
        }
        // load given raw IDs into SoundPool and store resulting stream IDs
        mSoundIds = new int[NOTES_IDS.length];
        for (int i = 0; i < NOTES_IDS.length; i++) {
            mSoundIds[i] = mSoundPool.load(context, NOTES_IDS[i], 1); // priority==1
        }
    }

    /** Constructor for PianoFragment functionality. rawIDs and buttonIDs should be parallel to each other. */
    public MCSoundPool(Context context, int maxStreams, int[] buttonIDs) {
        this(context, maxStreams); // create SoundPool
        // create a Map from the given Button IDs to the generated stream IDs
        mSoundMap = new HashMap<>();
        for (int i = 0; i < buttonIDs.length; i++) {
            mSoundMap.put(buttonIDs[i], mSoundIds[i]);
        }
    }

    /**
     * Plays a sound mapped to a particular PianoFragment Button.
     * @param button
     */
    public void playPianoKey(View button) {
        if (mSoundMap == null) {
            Log.e(TAG, "playPiano: mSoundMap has not been initialized.");
        }
        else {
            Integer soundID = mSoundMap.get(button.getId()); // get .wav ID from Button mapping
            if (soundID != null) {
                mStreamId = mSoundPool.play(soundID, 1, 1, 1, 0, 1);
            } else {
                Log.e(TAG, "playPianoKey: View ID does not have a mapping.");
            }
        }
    }

    public void playIntervalSequence(int firstID, int secondID) {

    }

    public void playIntervalUnison(int firstID, int secondID) {
        if (mStreamId != null) {
            mSoundPool.stop(mStreamId);
        }
        mStreamId = mSoundPool.play(firstID, 1, 1, 1, 0, 1);
        mStreamId = mSoundPool.play(secondID, 1, 1, 1, 0, 1);
    }

    /** Relinquishes resources used through {@link PianoFragment#onDestroy()}. */
    public void destroy() {
        mSoundPool.release();
        mSoundPool = null;
    }

} // End of class SoundPlayer
